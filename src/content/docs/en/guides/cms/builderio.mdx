---
title: Builder.io & Astro
description: Add content to your Astro project using Builder.ioâ€™s visual CMS
type: cms
service: Builder.io
stub: false
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro';

[Builder.io](https://www.builder.io/) is a visual CMS that supports drag-and-drop content editing for building websites. 

This recipe will show you how to connect your Builder space to Astro with zero client-side JavaScript.

:::tip[Official resource]
If you are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use one of Builder's integrations as an alternative to making raw fetch calls through the REST API.
:::

## Prerequisites

To get started, you will need to have the following:

* **A Builder account and space** - If you don't have an account yet, [sign up for free](https://www.builder.io/) and create a new space. If you already have a space with Builder, feel free to use it, but you will need to modify the code to match the model name (`blogpost`) and custom data fields.
* **A Builder API key** - This public key will be used to fetch your content from Builder. [Read Builder's guide on how your key](https://www.builder.io/c/docs/using-your-api-key#finding-your-public-api-key).

## Setting up credentials

To add your Builder API key and your Builder model name to Astro, create a `.env` file in the root of your project (if one does not already exist) and add the following variables:

```ini title=".env"
BUILDER_API_PUBLIC_KEY=YOUR_API_KEY
BUILDER_BLOGPOST_MODEL='blogpost'
```

Now, you should be able to use this API key in your project.

:::note
At the time of writing, [this key is public](https://www.builder.io/c/docs/using-your-api-key#prerequisites), so you don't have to worry about hiding or encrypting it.
:::

If you would like to have IntelliSense for your environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

```ts title="src/env.d.ts"
interface ImportMetaEnv {
  readonly BUILDER_API_PUBLIC_KEY: string;
}
```

Your project should now include these files:

<FileTree title="Project Structure">
- src/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json
</FileTree>


## Making a blog with Astro and Builder

The instructions below create an Astro blog using a Builder model (Type: "Section") called `blogpost` that contains two required text fields: `title` and `slug`.

### Setting up the preview

To use Builder's visual editor, create the page `src/pages/builder-preview.astro` that will render the special `<builder-component>`:

<FileTree title="Project Structure">
- src/
  - pages/
    - **builder-preview.astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content:

```astro title="src/pages/builder-preview.astro"
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
---

<html lang="en">
  <head>
    <title>Preview for builder.io</title>
  </head>
  <body>
    <header>This is your header</header>

    <builder-component model={builderModel} api-key={builderAPIpublicKey}
    ></builder-component>
    <script async src="https://cdn.builder.io/js/webcomponents"></script>

    <footer>This is your footer</footer>
  </body>
</html>

```

In the above example, `<builder-component>` tells Builder where to insert the content from its CMS.

#### Setting the new route as the preview URL

1. Copy the full URL of your preview, including the protocol, to your clipboard (e.g. `https://{your host}/builder-preview`). 

2. Go to the **Models** tab in your Builder space, pick the model you've created and paste the URL from step 1 into the **Preview URL** field. Make sure the URL is complete and includes the protocol, for example `https://`.

3. Click the **Save** button in the upper right.

:::tip
When you deploy your site, change the preview URL to match your production URL, for example `https://myAwesomeAstroBlog.com/builder-preview`.
:::

#### Testing the preview URL setup

1. Make sure your site is live (e.g. your dev server is running) and the `/builder-preview` route is working.

2. In your Builder space under the **Content** tab, click on **New** to create a new content entry for your `blogpost` model.

3. In the Builder editor that just opened, you should be able to see the `builder-preview.astro` page with a big **Add Block** in the middle.

:::tip[Troubleshooting]

Things can sometimes go wrong when setting up the preview. If something's not right, you can try one of these things:

* Make sure the site is live - for example, your dev server is running.
* Make sure that the URLs match exactly - the one in your Astro project and the one set in the Builder app.
* Make sure it's the full URL including the protocol, for example `https://`.
* If you're working in a virtual environment like [StackBlitz](https://stackblitz.com/) or [Gitpod](https://www.gitpod.io/), you might have to copy and paste the URL again when you restart your workspace, since this usually generates a new URL for your project.

For more ideas, read [Builder's troubleshooting guide](https://www.builder.io/c/docs/guides/preview-url-working).
:::

### Creating a blog post

1. In Builder's visual editor, create a new content entry with the following values:
    - **title:** 'First post, woohoo!'
    - **slug:** 'first-post-woohoo'
2. Complete your post using the **Add Block** button and add a text field with some post content .
3. In the text field above the editor, give your entry a name. This is how it will be listed in the Builder app.
4. When you're ready click the **Publish** button in the upper right corner.
5. Create as many posts as you like, ensuring that all content entries contain a `title` and a `slug` as well as some post content.

### Displaying a list of blog posts

Add the following content to `src/pages/index.astro` in order to display a list of all post titles, each linking to its own page:



```astro title="src/pages/index.astro" ins={18-99}
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
  `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    fields: ["data.slug", "data.title"].join(","),
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch();
---

<html lang="en">
  <head>
    <title>Blog Index</title>
  </head>
  <body>
    <ul>
      {
        posts.map(({ data: { slug, title } }) => (
          <li>
            <a href={`/posts/${slug}`}>{title}</a>
          </li>
        ))
      }
    </ul>
  </body>
</html>

```

Fetching via the content API returns an array of objects containing data for each post. The `fields` query parameter tells Builder which data is included (see highlighted code). `slug` and `title` should match the names of the custom data fields you've added to your Builder model.


The `posts` array returned from the fetch displays a list of blog post titles on the home page. The individual page routes will be created in the next step.

:::tip[framework integrations]
If you are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use one of Builder's integrations as an alternative to making raw fetch calls through the REST API.
:::


Go to your index route and you should be able to see a list of links each with the title of a blog post!

If you encounter any errors, you can always fall back to [Builder's API explorer](https://builder.io/api-explorer).

### Displaying a single blog post

Create the page `src/pages/posts/[slug].astro` that will [dynamically generate a page](/en/core-concepts/routing/#dynamic-routes) for each post.

<FileTree title="Project Structure">
- src/
  - pages/
    - index.astro
    - posts/
      - **[slug].astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the `getStaticPaths` function:

```astro title="src/pages/posts/[slug].astro"
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

  const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
      {
        apiKey: builderAPIpublicKey,
        fields: ["data.slug", "data.title"].join(","),
        cachebust: "true",
      }
    ).toString()}`
  )
    .then((res) => res.json())
    .catch
    // ...catch some errors...);
    ();

  return [
    ...posts.map(({ data: { slug, title } }) => [
      {
        params: { slug },
        props: { title },
      },
    ]),
  ];
}
---
```

This fetch call is the same you've used to [display a list of blog posts](#displaying-a-list-of-blog-posts). Here, the `getStaticPaths` function creates a static route for each blog post, based on the `slug` data field.

Next, add the following content:

```astro title="src/pages/posts/[slug].astro" ins={30-49}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

  const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
      {
        apiKey: builderAPIpublicKey,
        fields: ["data.slug", "data.title"].join(","),
        cachebust: "true",
      }
    ).toString()}`
  )
    .then((res) => res.json())
    .catch
    // ...catch some errors...);
    ();

  return [
    ...posts.map(({ data: { slug, title } }) => [
      {
        params: { slug },
        props: { title },
      },
    ]),
  ];
}

const { slug } = Astro.params;
const { title } = Astro.props;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the URL doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
  `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    url: encodedUrl,
    "query.data.slug": slug,
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch();
---
```

The `slug` returned from `getStaticPaths` is used to fetch the corresponding post. The HTML that Builder sends back is made of the blocks you put on the page in Builder's editor.

:::caution
This code relies on the fact that each content entry in the `blogpost` model has non-empty fields called `slug` and `title`. If you didn't create a fresh model for this guide, make sure that all content entries have these fields filled, including those that you started with.
:::

:::note
The variables `builderModel` and `builderAPIpublicKey` need to be created twice, since [`getStaticPaths` runs in its own isolated scope](/en/reference/api-reference/#getstaticpaths).
:::


Finally, render the HTML:

```astro title="src/pages/posts/[slug].astro" ins={52-99}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

  const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
      {
        apiKey: builderAPIpublicKey,
        fields: ["data.slug", "data.title"].join(","),
        cachebust: "true",
      }
    ).toString()}`
  )
    .then((res) => res.json())
    .catch
    // ...catch some errors...);
    ();

  return [
    ...posts.map(({ data: { slug, title } }) => [
      {
        params: { slug },
        props: { title },
      },
    ]),
  ];
}

const { slug } = Astro.params;
const { title } = Astro.props;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
  `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    url: encodedUrl,
    "query.data.slug": slug,
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch();
---

<html lang="en">
  <head>
    <title>{title}</title>
  </head>
  <body>
    <header>This is your header</header>

    <article>
      <Fragment set:html={postHTML} />
    </article>

    <footer>The is your footer</footer>
  </body>
</html>

```

This page matches [the `/builder-preview` page you created previously](#setting-up-the-preview).

Now when you click on a link on your index route, you should be able to see the blog post!

### Publishing your site

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

#### Rebuild on Builder changes

If your project is using Astro's default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build whenever you click **Publish** in the Builder editor.

##### Netlify

1. Go to your site dashboard, then **Site Settings** and click on **Build & deploy**.
2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.
3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

1. Go to your project dashboard and click on **Settings**.
2. Under the **Git** tab, find the **Deploy Hooks** section.
3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Builder

1. Have the URL ready that your hosting provider generated [in the previous step](#rebuild-on-builder-changes).
2. In your Builder dashboard go to the **Models** tab, and pick the **`blogpost`** model. 
3. In the new dialog, click on **Show More Options** and then on **Edit Webhooks** at the bottom.
4. Now add a new webhook by clicking on **Webhook** and then expand the webhook that appeared by clicking on it.
5. Paste the URL from step 0 that was generated by your hosting provider into the **Url** field.
6. The last thing to do is to click on **Show Advanced** under the URL field and click the toggle so that the option **Disable Payload** is **enabled**. Click on **Done** and you're done.

With this set up in place, when you click on the **Publish** button, Builder lets your hosting provider know that new content was added. This causes your site to be rebuilt and during this process, Astro fetches the newly published data. Nothing to do but lean back and pump out that sweet sweet content.

:::note
Not disabling the payload can cause the automated build process to break as your site grows and Builder sends more and more data to your hosting provider. With the payload disabled, Builder sends a simpler POST request.
::::


## Official Resources

- Check out [the official Builder.io starter project](https://github.com/BuilderIO/builder/tree/main/examples/astro-solidjs), which uses Astro and SolidJS.
- [Official Builder quickstart guide](https://www.builder.io/c/docs/quickstart#step-1-add-builder-as-a-dependency) - it covers both the use of the REST API as well as through an integration with a JavaScript framework like Qwik, React or Vue.
- [Builder's API explorer](https://builder.io/api-explorer)

## Community Resources

- Read [Connecting Builder.io's Visual CMS to Astro](https://www.hamatoyogi.dev/blog/astro-log/connecting-builderio-to-astro) by Yoav Ganbar.

