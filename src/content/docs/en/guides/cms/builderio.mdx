---
title: Builder.io & Astro
description: Add content to your Astro project using Builder.io’s visual CMS
type: cms
service: Builder.io
stub: false
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro';

[Builder.io](https://www.builder.io/) is a visual CMS that supports drag and drop content editing for building web sites.

At the end of this recipe you'll be able to create content in Builder's editor, and have your Astro site fetch this content automatically at build time using a webhook.

## Integrating with Astro

In this section, you'll use 2 [Builder's REST APIs](xxx) to connect your Builder space to Astro with zero client-side JavaScript.

:::note[Other options]
If You are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use [one of Builder's integrations](xxx).
:::

### Prerequisites

To get started, you will need to have the following:

* ??? *A basic knowledge of using a code editor / the command line* - You can read a beginner-friendly introduction here [https://www.tatianamac.com/posts/beginner-eleventy-tutorial-partii/#1a.-terminal-emulator]

* ??? *A basic knowledge of REST APIs*

* **An Astro project** - If you don't have an Astro project yet, our [Installation guide](/en/install/auto/) will get you up and running in no time. 

* **A Builder account and space** - If you don't have an account yet, [sign up for free](https://www.builder.io/) and create a new space.

* **A Builder API key** - This key will be used when fetching your content from Builder. [Here's](https://www.builder.io/c/docs/using-your-api-key) Builder's guide how to find it. 

* ??? **A basic understanding of Builder** - specifically [section models](xxx), [custom data fields]() and [the preview URL]().

### Setting up credentials

To add your Builder API key to Astro, create a `.env` file in the root of your project with the following variable:

```ini title="/.env"
BUILDER_API_PUBLIC_KEY=YOUR_KEY
```

Now, you should be able to use this API key in your project. 

:::note
At the time of writing, this key for the Builder API is public [xxx] - so you don't have to worry about hiding or encrypting it. 
:::

If you would like to have IntelliSense for your Contentful environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

```ts title="src/env.d.ts"
interface ImportMetaEnv {
  readonly BUILDER_API_PUBLIC_KEY: string;
}
```

Your root directory should now include these new files:

<FileTree title="Project Structure">
- src/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json
</FileTree>

:::tip
You could paste the key into your API call directly, but since you'll be making a few of these calls, it makes sense to put it in a separate file where you can access it from multiple places.

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.
:::

### Configuring Builder
Create a model that you'll use to build your site. This guide uses a [section model](xxx) representing a blog post. 

#### Connecting the Preview URL 

:::info
If you want to dig in, [read more about the preview URL in the Builder docs](https://www.builder.io/c/docs/html-api#previewing-content-on-your-site).
:::

To use Builder's drag-and-drop editor, you'll create a page that returns the special `<builder-coponent>`. This component tells Builder where to insert the content from its CMS - it represents the portion of the page that's editable in the Builder app. 

In this guide the `<builder-component>` represents the content of a blog post. Accordingly, we wrap it in our `<BaseLayout>` to simulate how it would look on the final page.

1. Create a file named `builder-preview.astro` in your `/pages` folder with the following content:

```astro title="src/pages/builder-preview.astro"
---
import BaseLayout from "../layouts/BaseLayout.astro";

const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
---

<BaseLayout>
    <header>
      Here be a header
    </header>

    <builder-component model={builderModel} api-key={builderAPIpublicKey}
    ></builder-component>
    <script async src="https://cdn.builder.io/js/webcomponents"></script>

    <footer>
      Here be a footer
    </footer>
</BaseLayout>
```

2. Start your astro project site (e.g. start dev server) and go to the route corresponding to the file you just created. Copy the URL. It might be something like `https://localhost:3000/builder-preview`. The exact URL will depend on your project environment.

3. With the URL copied, in your Builder space, go to the **Models** tab, pick the model that you've created and paste it in the **Preview URL** field. Make sure the URL is complete, including the `https` part! 

:::note
When you deploy your site, change the preview URL to match your production URL like `https://myBlog.com/builder-preview`.
:::

4. In your Builder space under the **Content** tab, click on **New** to create a new content entry and if a list pops up choose the model you just created.

5. In the Builder editor that just opened, you should be able to see your site with a big inviting **+ Add Block** in between!

[screenshot]xxx

:::tip
**Troubleshooting**

Things can sometimes go wrong when setting up the preview. If the preview doesn't work, you can try one of the following things:

* Make sure that the routes match exactly - your Astro route and the one in your Builder preview-URL. Watch out for typos!
* Make sure you include the full URL including the protocol (like `https://`)
* Make sure the site is live - your server is running 
* If you're working in a virtual environment like *Stackblitz* or *Gitpod*, you might have to go through this process again when you restart your workspace, since this usually generates a new URL for your project.

For more help, read (Builder's troubleshooting guide)[https://www.builder.io/c/docs/guides/preview-url-working].
:::

#### Fetching data
(xxx work on this --- simplify)

To test this setup, create a new piece of content for the [section model you've set up in step 3](configuring builder). In Builder's editor click on **+ Add Block** and add some text. Give the content entry a name (above th editor) and then click **Publish**. 

To display the blocks You just added, fetch their HTML using Builder's API. Your component might look like this:

```astro title="/src/pages/Somepage.astro
---
    import BaseLayout from "../layouts/BaseLayout.astro";

const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = 'blogpost'

// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
    `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
        apiKey: builderAPIpublicKey,
        url: encodedUrl,
        cachebust: "true",
    }).toString()}`
)
    .then((res) => res.json())
    .catch(
      // ...catch more errors...
      );
---

<BaseLayout pageTitle={'somepage'}>
    <Fragment set:html={postHTML} />
</BaseLayout>
```

:::info
Builder has several APIs and which to use depends on what kind of data You want to fetch

(This assumes that You want to use Builder's REST API as opposed to an integration)

1. If You want to get the blocks that You've added in the Builder editor, use the [QWIK API](xxx). This will give You pre-rendered HTML that you can directly put in your Astro page. (see above)

2. If You want to fetch your content's custom data fields like a post's `title` or `slug`, use Builder's Content API [xxx]. [See a later section of this guide for an example]().
:::

## Making a blog with Astro and Builder

With the integration set up, you can now create a blog with Astro and Builder.

There are lots of ways to integrate Builder with Astro and structure your content in Builder's CMS. In this guide we'll keep it simple using Builder's REST APIs to fetch our content and a section model representing our blog posts. One use case for this might be if You want to build and manage a website for someone, but give them the power to design their own content using a visual tool like Builder.  

By the end of this guide you'll have a website that
* ✅ has a base layout, managed with Astro 
* ✅ has blog posts which can be edited in Builder's visual editor
* ✅ is totally static with 0 client side JavaScript
* ✅ automatically updates each time you change something in Builder

### Prerequisites

1. **A Builder space** - For this tutorial, we recommend using a new space. If you already have a space with Builder, feel free to use it, but you will need to modify the code to match the model name and custom data fiels.

2. **An Astro project integrated with a Builder section model** - Follow [the guide above](#integrating-with-astro) to set this up.


### Creating A Base Layout
Create the greater layout in which you'll later embed each blog post:

```astro title='/src/layouts/BaseLayout'
---
import "../styles/global.css";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
const { pageTitle } = Astro.props;
---

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width" />
        <meta name="generator" content={Astro.generator} />
        <title>{pageTitle}</title>
    </head>
    <body>
        <Header />
        <h1>{pageTitle}</h1>
        <slot />
        <Footer />
        <script>
            import "../scripts/menu";
        </script>
    </body>
</html>
```

This `BaseLayout` is the same as you'd be left with at the end of the [getting started with Astro tutorial](xxx).

The idea here is to have the content of the <Header> and <Footer> come from Astro files, while the blog post will go into the <slot>. You'll create a blog post in the Builder app in the next step. 

:::note
This is one workflow among many. It demonstrates how You could split up the development of a site - the writers can design posts using Builder's visual editor, while other teams can handle more technical stuff or more perennial content such as the header and footer. 

Experiment with other setups and find one that suits your team's needs!
:::

### Creating the data model for each blog post

Follow [Builder's official tutorial](https://www.builder.io/blog/creating-blog) for creating a blog post model - it has gifs!

In short, to create a model for your blogpost go to the Builder app and click on the **Models** tab. Click on the <kbd>+ Create Model</kbd> button and create a model of the type `section` (or go to an existing section model You want to use for this tutorial). A section model means that the content can sit between other elements of a page - like the <Header> and <Footer> that are part of our <BaseLayout>! 

In that new model add 2 custom fields by clicking **+ New Custom Field**. This will be the data *about* a blog post (as opposed to the content itself). For this tutorial add the following fields:

   - `title` - A required field of the type `text` with the default `_`
   - `slug` - Again, a required field of the type `text` with the default `_`

The default values don't really matter at this point, but we want to make sure there is always something here, since you'll be relying on this data when building your site.

:::note
You can add whatever fields You like. Other popular choices are fields that contain the author's name, the date of publication or the image to be used for the post.  
:::

### Creating a blog post
// ### Creating New Content
// ### Using Builder's Visual Editor

:::caution
Before You can create new content in Builder, make sure the preview URL for your model is working. See the [instructions](xxx) above. 
:::

To add new content, go to the **Content** tab, then click on *+ New* and choose the `blogpost` model You've just created. If You followed the steps under [integrating with Astro] and everything worked, you should see something like this: 

[screenshot with empty blogpost]

The data fields you've just created are in the panel on the right under the *options* tab. Fill those in and then add some content to your post! To do that, click on the *+ Add Block* button and add whatever you want - maybe a text field with some text to start with. Here is where you can use the full power of Builder's drag and drop editor and design your blog post to your heart's contents!  

When You're ready click on the big blue `Publish` in the upper right. 

The content is now live in the Builder CMS. 

To actually connect this content with your website, you'll create a catch-all route that fetches and renders it.

### Creating the component for a blog post 
### Displaying the content of a blogpost

Return to your Astro ptoject and create the following file:

<FileTree title="Project Structure">
    - src/pages/posts/**[slug].astro** - .env - astro.config.mjs - package.json
</FileTree>

Then add the following content: 

```astro title="src/pages/posts/[slug].astro"
---
    import BaseLayout from "../../layouts/BaseLayout.astro";

const builderModel = 'blogpost'
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;


// fetch all posts, just as in the previous step
// 💥 TO REVIEWER: open to suggestions how to simplify this
export async function getStaticPaths() {
  const builderModel = 'blogpost'
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;


    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug, title } }) => [
            {
                params: { slug },
                props: { title },
            },
        ]),
    ];
}
const { slug } = Astro.params;
const { title } = Astro.props;

// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
    `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
        apiKey: builderAPIpublicKey,
        url: encodedUrl,
        "query.data.slug": slug,
        cachebust: "true",
    }).toString()}`
)
    .then((res) => res.json())
    .catch(
      // ...catch more errors...);
        )
---

<BaseLayout pageTitle={title}>
    <Fragment set:html={postHTML} />
</BaseLayout>
```

::: caution
This code is relying on the fact that each content entry in the `blogpost` model has in fact fields called `title` and `slug`, so make sure these fields are required and all pieces of content have them, including those that might have been created before. It's best to create a new model with the proper rules set up from the beginning for that reason. 
:::

This file generates a [dynamic route](https://docs.astro.build/en/core-concepts/routing/#static-ssg-mode) for each blog post based on the `slug` custom data field You filled when You created your blogpost on Builder. The HTML used here is made of the blocks You put on the page in Builder's editor!    

:::note
The HTML is put into the slot of our `<BaseLayout>` matching our `builder-preview` page created in step 1 [xxx]. 
:::

Now you can go to the route `/posts/hello-world` and you should be able to see your blog post! (The full URL depends on how you are running your project and might go something like `localhost:3000/posts/hello-world`)

### Creating a list of all blog posts
To make a list of all your content, go to your `src/pages` folder and create a file called `BlogPostList.astro` with the following content:

```astro title="src/pages/BlogPostList.astro" ins={12}
---
import BaseLayout from "../layouts/BaseLayout.astro";

const pageTitle = "My Astro Learning Blog";

const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v2/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
    .then((res) => res.json())
    .catch(
            // ...catch some errors...
    );
---

<BaseLayout pageTitle={pageTitle}>
    <ul>
        {
            posts.map(({ data: { slug, title } }) => (
                <a href={`/posts/${slug}`} > 
                {title}
                </a>
            ))
        }
    </ul>
</BaseLayout>
```
This will generate a list of titles each linking to the appropiate blog post. Notice how they are using the same route - `/posts/${slug}` - that you've set up in the previous step (xxx).

:::note
The magic happens on lines ... and .... `slug` and `title` match the fields you've set up in your Builder model during the previous step(xxx). (All of your custom fields are availabe under the `data` object.) We are telling the Builder API to give us the `slug` and `title` of all our blog posts so that we can create our links using this data. 
:::

[screenshot showing matching fields: in code editor on one side, on builder.io on the other model custom fields]

In this example we are keeping it simple and olnly fetching the bare necessities to show You how to create a list of blog posts. But You can fetch any data that you've set up in your Builder model - the name of the author, the length of the posts, or the publication date - it all depends on your Builder model. 

Now You should be able to go to the `/BlogPostList` route and see your first blog post getting listed! You can even follow the link and it should lead You to the blogpost. 

To finish off, You'll set up a web hook so that as You publish new posts on Builder, this list will get updated automatically.

### Publishing your site

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

xxxchange preview URL?

#### Rebuild on Builder changes

If your project is using Astro's default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build whenever You click **Publish** in the Builder editor.

##### Netlify

To set up a webhook in Netlify:

1. Go to your site dashboard, then **Site Settings** and click on **Build & deploy**.

2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

To set up a webhook in Vercel:

1. Go to your project dashboard and click on **Settings**.

2. Under the **Git** tab, find the **Deploy Hooks** section.

3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Builder

Builder provides a guide here()?

In your Builder dashboard go to **Models**, and click on the **blogpost** model. This is the same spot where You've created Your custom fields `title` and `slug` in a previous step(). Above these fields click on **Show More Options** and then on **Edit Webhooks** at the bottom. Now add a new webhook by clicking on **+ Webhook** and then expand the Webhook that appeared by clicking on it. Paste the URL that was generated by your hosting provider and You're almost there! The last thing to do is to click on **Show Advanced** under the URL field and click the toggle so that the option **Disable Payload** is **enabled**. Click on **Done** and You're done!

:::note
Not disabling the payload can cause the automated build process to break as our website and the payload get bigger and bigger. With the payload disabled, Builder sends a simple POST request each time and we can fetch the data ourselves through the magic of Astro!  
::::

Now each time You click on the **Publish** button, Builder lets our hosting provider know that we want to rebuild our site and during the build process our websites fetches our newly published data! Nothing to do but lean back and pump out that sweet sweet content. 

## Official Resources

- Check out [the official Builder.io starter project](https://github.com/BuilderIO/builder/tree/main/examples/astro-solidjs), which uses Astro and SolidJS

## Community Resources

- Read [Connecting Builder.io's Visual CMS to Astro](https://www.hamatoyogi.dev/blog/astro-log/connecting-builderio-to-astro) by Yoav Ganbar

---

## UNUSED copy
To display each blogpost you'll create a catch-all route [xxx] matching the route `/posts/${slug}` from the previous step [xxx].
* Since you'll be using the name of this model in each API call, it makes sense to set it as an environment variable. See the previous section on how to do that [xxx]. 

## TODO
[x] write draft
[x] follow the tutorial: general connecting  ("part 1")
[x] follow the tutorial: build blog ("part 2")
[x] dynamic preview URL??????
[x] go through stars * notes, mb make TODOs out of them
[x] ask Discord about tone and structure
[x] read WRITING.md
[x] look at other astro stuff for ideas about tone and structure --- contently, storyblok, ghost
* from contentful/ghost: take the prerequisite section about setting up the .env file 
* from Ghost CMS: take the structure of putting a <FileTree> at the beginning of each section
* from both: think about mb taking a step-by-step approach to the [slug] section --- 
[] unify the use of <FileTree>
[] unify the structure of instructions --- numbering steps or not
[] give concrete instructions instead of suggestions --- e.g. tell what title and what slug to put in (makes giving instructions simpler later on)
[] settle on tone and address in terms of you/You/we/let's  
[] fix the flow of the instructions: in part 2 there is no mention of the preview URL. idea 1: leave part 1 to be a content section model, then just assume that and build on that. idea 2: link back to the preview URL / mention it again. idea 3: give the instructions again. also relevant here: simplify the first part by making it a **page** model?
[] go through code -- AI 
  [] take out import scripts.js in <Baselayout> 
  [] very first code example --- is <BaseLayout> needed?
  [] sort out the BUILDER_BLOGPOST_MODEL issue
[] unify tone --- AI, 
[] fix typos -- AI
[] revise, simplify, clarify -- AI
[] add links
[] add screenshots 
[] preview site
[] revise again --- AI
[] write PR --- mention new ideas
[] ask Discord about squashing commits
[] add a logo to `/public/logos`? see here: https://github.com/withastro/docs/blob/main/RECIPES.md#cms-deploy-and-migrate

## FURTHER ideas
* make WRITING.md more visible (e.g. put it on github repo)
* do this with an integration 
* add section for SSR whatever that is
* 🧠 High level stuff: explain how to structure the data of a blogpost - what to put in a data field and what to put directly via Builder's drag and drop. might be more of a tutorial about how to map builder templates to components
