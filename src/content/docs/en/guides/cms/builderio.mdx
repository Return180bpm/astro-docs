---
title: Builder.io & Astro
description: Add content to your Astro project using Builder.io’s visual CMS
type: cms
service: Builder.io
stub: false
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro';

[Builder.io](https://www.builder.io/) is a visual CMS that supports drag and drop content editing for building web sites.

At the end of this recipe you'll be able to create blog posts in Builder's visual editor and have your Astro site fetch this content automatically at build time using a webhook.

To do this, you'll use 2 [Builder's REST APIs](xxx) to connect your Builder space to Astro with zero client-side JavaScript.

:::note[Other options]
If You are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use [one of Builder's integrations](xxx).
:::

## Prerequisites

To get started, you will need to have the following:

* **An Astro project** - If you don't have an Astro project yet, our [Installation guide](/en/install/auto/) will get you up and running in no time. 

* **A Builder account and space** - If you don't have an account yet, [sign up for free](https://www.builder.io/) and create a new space. If you already have a space with Builder, feel free to use it, but you will need to modify the code to match the model name and custom data fiels.

* **A Builder API key** - This key will be used when fetching your content from Builder. [Here's](https://www.builder.io/c/docs/using-your-api-key) Builder's guide how to find it. 

### Foundational knowledge
This is some of the stuff that this guide assumes that you know and won't be explaining.

**You don't have to be an expert in any of these to finish this guide. When in doubt, just start hacking! If you get stuck, you can always ask for help on [our super friendly Discord 💜](xxx)**.

* **A basic knowledge of JavaScript** - destructuring assignment, fetch, then...catch blocks
* **A basic knowledge of how Astro works** - Relevant topics for this guide: SSGs, dynamic URLs, structure of an .astro file.

* **How to use a code editor** - You can read a beginner-friendly introduction [here](https://www.tatianamac.com/posts/beginner-eleventy-tutorial-partii/#2.-source-code-editor).

* **The concept of a REST APIs** - we send queries, they send back data.

* **A basic understanding of Builder** - specifically [section models](xxx), [custom data fields](xxx) and [the preview URL](https://www.builder.io/c/docs/html-api#previewing-content-on-your-site).

## Setting up credentials

To add your Builder API key to Astro, create a `.env` file in the root of your project with the following variable:

```ini title="/.env"
BUILDER_API_PUBLIC_KEY=YOUR_API_KEY
```

Now, you should be able to use this API key in your project. 

:::note
At the time of writing, this key for the Builder API is public [xxx] - so you don't have to worry about hiding or encrypting it. 
:::

If you would like to have IntelliSense for your environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

```ts title="src/env.d.ts"
interface ImportMetaEnv {
  readonly BUILDER_API_PUBLIC_KEY: string;
}
```

Your project should now include these new files:

<FileTree title="Project Structure">
- src/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json
</FileTree>

:::note
You could paste the key into your API call directly, but since you'll be making a few of these calls, it makes sense to put it in a separate file where you can access it from multiple places.

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.
:::

## Making a blog with Astro and Builder

With the set up above, you can now create a blog with Astro and Builder.

### Creating a model for a blogpost

:::note
You can also follow [Builder's official tutorial](https://www.builder.io/blog/creating-blog) for creating a blogpost model - it has gifs!
:::

In the Builder app create the model that will represent a blogpost: go to the **Models** tab and click the **+ Create Model** button to create model with the following fields and values:

- **Type:** Section
- **Name:** blogpost
- **Description:** This model is for a blog post

:::note
A section model means that the content can sit between other elements of a page - like a `<header>` and `<footer>`, for example. 
:::

In your new model use the **+ New Custom Field** button to create 2 new fields:

1. Text field
    - **Name:** "title"
    - **Required:** Yes
    - **Default value** "I forgot to give this a title"
    (leave the other parameters as their defaults)
2. Text field
    - **Name:** "slug"
    - **Required:** Yes
    - **Default value** "some-slugs-take-their-time"
    (leave the other parameters as their defaults)

Then click the **Save** button in the upper right. 

:::caution
This guide relies on these fields to be exactly like this and later code will not run correctly if these fields don't exist, are empty, or the titles misspelled.
:::

:::caution
Make sure your slug is not just a number!

There is a pitfall with the `slug` field: it allows you to enter a number but this seems to break the API call later and is hard to debug. 
:::

Put the name of the model in the `.env` file for convenience:
```ini title="/.env" ins={2}
BUILDER_API_PUBLIC_KEY=YOUR_KEY
BUILDER_BLOGPOST_MODEL='blogpost'
```

### Setting up the preview URL

:::note
The official Builder guide on setting up a preview URL with the HTML API is [here](https://www.builder.io/c/docs/html-api#previewing-content-on-your-site).
:::

#### Creating a route for the preview
To use Builder's visual editor, create the page `src/pages/builder-preview.astro` that will render the special `<builder-component>`:

<FileTree title="Project Structure">
- src/
  - pages/
    - **builder-preview.astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content:

```astro title="src/pages/builder-preview.astro"
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
---
<html lang="en">
  <head>
    <title>Preview for builder.io</title>
  </head>
  <body>     
    <header>
      Here be a header
    </header>

    <builder-component model={builderModel} api-key={builderAPIpublicKey}
    ></builder-component>
    <script async src="https://cdn.builder.io/js/webcomponents"></script>

    <footer>
      Here be a footer
    </footer>
  </body>     
</html>
```

`<builder-component>` tells Builder where to insert the content from its CMS - it represents the portion of the page that's editable in the Builder app. In this guide it stands for the content of a blog post. The whole `builder-preview.astro` page recreates how a blog post will be embedded into the site later on - sitting between a `<header>` and a `<footer>`.

#### Setting the new route as the preview URL
1. Copy the full URL of the `/builder-preview` route you just created to your clipboard. One way to do this is to run your Astro project (e.g. start the dev server), and type in the route in the address bar of the browser. Then copy the full URL to your clipboard, including the protocol, for example `https://`. (You might have to click into the address bar again for the protocol to show.) 

:::note
The full URL might go something like `https://localhost:3000/builder-preview` and will depend on your project environment.
:::

2. Go to the **Models** tab in your Builder space, pick the model  you've created and paste the URL from step 1 into the **Preview URL** field. Make sure the URL is complete and includes the protocol, for example `https://`.

3. Click the **Save** button in the upper right. 

:::note
When you deploy your site, change the preview URL to match your production URL, for example `https://myAwesomeAstroBlog.com/builder-preview`.
:::

#### Testing the preview URL set up 
1. Make sure your site is live (e.g. your dev server is running) and the `/builder-preview` route is working.

2. In your Builder space under the **Content** tab, click on **New** to create a new content entry for your "blogpost" model.

3. In the Builder editor that just opened, you should be able to see the `builder-preview.astro` page with a big inviting **+ Add Block** in the middle!

[screenshot]xxx

:::tip[Troubleshooting]

Things can sometimes go wrong when setting up the preview. If the preview doesn't work, you can try one of the following things:

* Make sure the site is live - for example, your dev server is running 
* Make sure that the URLs match exactly - the one in your Astro project and the one set in the Builder app
* Make sure you include the full URL including the protocol (like `https://`)
* If you're working in a virtual environment like *Stackblitz* or *Gitpod*, you might have to copy and paste the URL again when you restart your workspace, since this usually generates a new URL for your project

For more ideas, read (Builder's troubleshooting guide)[https://www.builder.io/c/docs/guides/preview-url-working].
:::

### Creating a blog post

:::caution[Prerequisites]
Before You can create new content in Builder, make sure the preview URL for your model is working. See the [instructions](/#Setting-up-the-Preview-URL) above. 
:::

:::note
Find Builder's guide how to create content [here](xxx). It has gifs!
:::

1. Open the visual editor for a content entry of our 'blogpost' model. If You've followed the steps under [testing it](/#testing-the-preview-url-set-up), you can use that content entry. Otherwise create it now: Go to the **Content** tab in your Builder space and click on **+ New**. 

1. In the panel on the right under the **options** tab, you should see the data fields 'title' and 'slug'. These are the fields you've created in a previous step(xxx). Fill them in with the following values:
- **title:** 'First post, yeah!'
- **slug:** 'first-post-yeah'

2. Design your post! Click on the *+ Add Block* button and add something - maybe a text field with some text to start with.

3. In the text field above the editor, give your entry a name. This is how it will be listed in the Builder app. 

4. When You're ready click **Publish** button in the upper right corner. 

Your content is now live in the Builder CMS but not part of your Astro project yet. You'll be fetching and displaying it in the following steps. 

Feel free to add as many blog posts as you want, then switch to your favorite code editor to start hacking with Astro!

### Displaying a list of blog posts

Create the page `src/pages/index.astro` that will display a list of post titles, each linking to its own page:

<FileTree title="Project Structure">
- src/
  - pages/
    - **index.astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content:

```astro title="src/pages/index.astro" /title|slug/
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
    .then((res) => res.json())
    .catch(
            // ...catch some errors...
    );
---
```

:::caution[API URls]
URLs used to access APIs change fairly frequently. Check [Builder's API reference](https://www.builder.io/c/docs/content-api-versions) for the latest. 
:::

Fetching via the content API returns an array of objects containing data for each post. The `fields` query parameter tells Builder which data to send (see highlighted code). `slug` and `title` should match the names of the custom data fields in your Builder model (see this step xxx). 
:::

???[screenshot showing matching fields: in code editor on one side, on builder.io on the other model custom fields]

Use the `posts` array returned from the fetch to display a list of blog posts on the page:

```astro title="src/pages/index.astro" ins={19-99}
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
    .then((res) => res.json())
    .catch(
            // ...catch some errors...
    );
---
<html lang="en">
  <head>
    <title>Blog Index</title>
  </head>
  <body>
    <ul>
        {
            posts.map(({ data: { slug, title } }) => (
                <a href={`/posts/${slug}`} > 
                {title}
                </a>
            ))
        }
    </ul>
  </body>
</html>
```

Go to your `/` route and you should be able to see a list of links each with the title of a blog post!

:::tip
To debug or fine-tune the API results, you can use [Builder's API explorer](https://builder.io/api-explorer) 
:::

### Displaying a single blogpost

Create the page `src/pages/posts/[slug].astro` that will [dynamically generate a page](/en/core-concepts/routing/#dynamic-routes) for each post.

<FileTree title="Project Structure">
- src/
  - pages/
    - index.astro
    - posts/
      - **[slug].astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the `getStaticPaths` function: 

```astro title="src/pages/posts/[slug].astro"
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug, title } }) => [
            {
                params: { slug },
                props: { title },
            },
        ]),
    ];
}
```

The fetch call is very similar to the one in the previous step(xxx). Here, the `getStaticPaths` function creates a static route for each blog post, based on the `slug` data field.

alt: This file generates a [dynamic route](https://docs.astro.build/en/core-concepts/routing/#static-ssg-mode) for each blog post based on the `slug` custom data field You filled when You created your blogpost on Builder.     

[⚡️ TO REVIEWER: I've looked into ways how to not repeat this fetch call and landed on the `integrations API`. That seemed a little complex. I'm thinking mb it's not too bad to repeat this code here, but I'm very open for suggestions or pointers on how to DRY it']

Next, add the following content:

```astro title="src/pages/posts/[slug].astro" ins={29-99}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug, title } }) => [
            {
                params: { slug },
                props: { title },
            },
        ]),
    ];
}

const { slug } = Astro.params;
const { title } = Astro.props;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
    `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
        apiKey: builderAPIpublicKey,
        url: encodedUrl,
        "query.data.slug": slug,
        cachebust: "true",
    }).toString()}`
)
    .then((res) => res.json())
    .catch(
      // ...catch more errors...);
        )
---
```

Here, you are fetching the HTML of each blogpost based on its `slug` custom data field. This HTML is made of the blocks you put on the page in Builder's editor.

::: caution
This code is relying on the fact that each content entry in the `blogpost` model has in fact fields called `slug`. If you didn't create a fresh model for this guide, make sure that all content entries have this field filled, including those that you started with.
:::

:::note
The variables `builderModel` and `builderAPIpublicKey` need to be created again on line (xxx), since [`getStaticPaths` runs in its own isolated scope](https://docs.astro.build/en/reference/api-reference/#getstaticpaths).
:::


Finally, render the HTML:

```astro title="src/pages/posts/[slug].astro" ins={51-99}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug, title } }) => [
            {
                params: { slug },
                props: { title },
            },
        ]),
    ];
}

const { slug } = Astro.params;
const { title } = Astro.props;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
    `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
        apiKey: builderAPIpublicKey,
        url: encodedUrl,
        "query.data.slug": slug,
        cachebust: "true",
    }).toString()}`
)
    .then((res) => res.json())
    .catch(
      // ...catch more errors...);
        )
---
<html lang="en">
  <head>
    <title>{title}</title>
  </head>
  <body>     
    <header>
      Here be a header
    </header>

    <article>
        <Fragment set:html={postHTML} />
    </article>

    <footer>
      Here be a footer
    </footer>
  </body>     
</html>
```

This page matches the `/builder-preview` page you created previously (xxx).

Now when you click on a link on your index route, you should be able to see the blog post!

### Publishing your site

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

#### Rebuild on Builder changes

If your project is using Astro's default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build whenever You click **Publish** in the Builder editor.

##### Netlify

To set up a webhook in Netlify:

1. Go to your site dashboard, then **Site Settings** and click on **Build & deploy**.

2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

To set up a webhook in Vercel:

1. Go to your project dashboard and click on **Settings**.

2. Under the **Git** tab, find the **Deploy Hooks** section.

3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Builder

:::note
Builder provides a guide for setting up a webhook [here](https://www.builder.io/c/docs/webhooks).
:::

To set up a webhook in Builder: 

0. Have the URL ready that your hosting provider generated in the previous step.
1. In your Builder dashboard go to the **Models** tab, and pick the **blogpost** model. 
2. In the new dialog, click on **Show More Options** and then on **Edit Webhooks** at the bottom.
3. Now add a new webhook by clicking on **+ Webhook** and then expand the Webhook that appeared by clicking on it.
4. Paste the URL from step 0 that was generated by your hosting provider into the **Url** field.
5. The last thing to do is to click on **Show Advanced** under the URL field and click the toggle so that the option **Disable Payload** is **enabled**. Click on **Done** and you're done.

With this set up in place, when you click on the **Publish** button Builder lets your hosting provider know that new content was added. This causes your site to be rebuilt and during this process Astro fetches the newly published data. Nothing to do but lean back and pump out that sweet sweet content. 

:::note
Not disabling the payload can cause the automated build process to break as your website gets bigger and bigger. With the payload disabled, Builder always sends a simple POST request.
::::


## Official Resources

- Check out [the official Builder.io starter project](https://github.com/BuilderIO/builder/tree/main/examples/astro-solidjs), which uses Astro and SolidJS

## Community Resources

- Read [Connecting Builder.io's Visual CMS to Astro](https://www.hamatoyogi.dev/blog/astro-log/connecting-builderio-to-astro) by Yoav Ganbar

---

## TODO
[x] write draft
[x] follow the tutorial: general connecting  ("part 1")
[x] follow the tutorial: build blog ("part 2")
[x] dynamic preview URL??????
[x] go through stars * notes, mb make TODOs out of them
[x] ask Discord about tone and structure
[x] read WRITING.md
[x] look at other astro stuff for ideas about tone and structure --- contently, storyblok, ghost
[x] from contentful/ghost: take the prerequisite section about setting up the .env file 
[x] simplify: remove part 1, give instructions for setting up the preview URL in the blog section
[x] fix the flow of the instructions: in part 2 there is no mention of the preview URL. idea 1: leave part 1 to be a content section model, then just assume that and build on that. idea 2: link back to the preview URL / mention it again. idea 3: give the instructions again. also relevant here: simplify the first part by making it a **page** model?
[x] do a big general revision - tone, code, flow
[x] unify tone --- we vs you, let's
[x] remove unused copy
[x] unify the use of `<FileTree>`
* from Ghost CMS: take the structure of putting a` <FileTree>` at the beginning of each section
[x] unify the structure of instructions --- numbering steps or not
* from both: think about mb taking a step-by-step approach to the [slug] section --- 
[x] give concrete instructions instead of suggestions --- e.g. tell what title and what slug to put in (makes giving instructions simpler later on)
[x] go through code -- AI
  [x] remove `<BaseLayout>` references
  [x] simplify - destructuring? see also WRITING.md on destructuring props
  [x] tidy up comments 
  [x] sort out the BUILDER_BLOGPOST_MODEL issue
  [x] preview site and edit diffs to highlight appropiate lines
[x] go through the tutorial and test it again --- start with empty astro projo
[] check spots marked with "???"
[] add links
[] add screenshots 
[] preview site - 
* pay attention to how headings are being rendered in table of contents --- are they too long?
* unify flow of code snippet - explanation - info box
[] revise, simplify, clarify -- AI
[] fix typos -- AI
* dodgy: no 'fetching data section'
* awkward: some repetition between #### testing it and the next step ### creating a blog post. idea: remove testing it and put create a blog post in its place
[] write PR --- mention new ideas
[] ask Discord 
* squashing commits
* screenshots
[] add a logo to `/public/logos`? see here: https://github.com/withastro/docs/blob/main/RECIPES.md#cms-deploy-and-migrate

## FURTHER ideas
* make WRITING.md more visible (e.g. put it on github repo)
* do this with an integration 
* add section for SSR whatever that is
* 🧠 High level stuff: explain how to structure the data of a blogpost - what to put in a data field and what to put directly via Builder's drag and drop. might be more of a tutorial about how to map builder templates to components
