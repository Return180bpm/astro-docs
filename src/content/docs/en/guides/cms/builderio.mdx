---
title: Builder.io & Astro
description: Add content to your Astro project using Builder.io’s visual CMS
type: cms
service: Builder.io
stub: false
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro';

[Builder.io](https://www.builder.io/) is a visual CMS that supports drag and drop content editing for building web sites.

At the end of this recipe you'll be able to create blog posts in the Builder app and have your Astro site update with this new content automatically using a webhook. 

To do this, you'll use Builder's [Content API](https://www.builder.io/c/docs/content-api) and [Qwik API](https://www.builder.io/c/docs/qwik-api) to connect your Builder space to Astro with zero client-side JavaScript.

:::tip[Official resource]
If you are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use one of Builder's integrations as an alternative to making raw fetch calls through the REST API.
:::

## Prerequisites

To get started, you will need to have the following:

* **A Builder account and space** - If you don't have an account yet, [sign up for free](https://www.builder.io/) and create a new space. If you already have a space with Builder, feel free to use it, but you will need to modify the code to match the model name and custom data fields.

* **A Builder API key** - This public key will be used to fetch your content from Builder. [Read Builder's guide on how your key](https://www.builder.io/c/docs/using-your-api-key#finding-your-public-api-key). 

### Foundational knowledge

This is some of the stuff that this guide assumes that you know and won't be explaining.

You don't have to be an expert in any of these to finish this guide. When in doubt, just start hacking! If you get stuck, you can always ask for help on [our Discord](https://astro.build/chat).

* **A basic knowledge of JavaScript** - Including [destructuring assignments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring) and [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch).

* **A basic knowledge of how Astro works** - Including [`.astro` files](/en/core-concepts/astro-pages/#astro-pages) and [dynamic routes](/en/core-concepts/routing/#dynamic-routes).

* **The concept of a REST APIs** - [Read more about what REST APIs are here](https://www.freecodecamp.org/news/what-is-rest-rest-api-definition-for-beginners/).

* **A basic understanding of Builder or another CMS system** - especially the Builder-specific [preview URL](https://www.builder.io/c/docs/html-api#previewing-content-on-your-site), as well as [section models](https://www.builder.io/c/docs/models-sections) and [custom data fields](https://www.builder.io/c/docs/custom-fields).

## Setting up credentials

To add your Builder API key to Astro, create a `.env` file in the root of your project with the following variable:

```ini title="/.env"
BUILDER_API_PUBLIC_KEY=YOUR_API_KEY
```

Now, you should be able to use this API key in your project. 

:::note
At the time of writing, [this key is public](https://www.builder.io/c/docs/using-your-api-key#prerequisites), so you don't have to worry about hiding or encrypting it. 
:::

If you would like to have IntelliSense for your environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

```ts title="src/env.d.ts"
interface ImportMetaEnv {
  readonly BUILDER_API_PUBLIC_KEY: string;
}
```

Your project should now include these new files:

<FileTree title="Project Structure">
- src/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json
</FileTree>

:::note
You could paste the key into your API call directly, but since you'll be making a few of these calls, it makes sense to put it in a separate file where you can access it from multiple places.

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.
:::

## Making a blog with Astro and Builder

With the set up above, you can now create a blog with Astro and Builder.

### Creating a model for a blog post

:::tip[For visual types]
You can find videos showing this procedure in [Builder's official tutorial on creating a model](https://www.builder.io/blog/creating-blog#creating-a-blog-article-model).
:::

In the Builder app create the model that will represent a blog post: go to the **Models** tab and click the **Create Model** button to create model with the following fields and values:

- **Type:** Section
- **Name:** "blogpost"
- **Description:** "This model is for a blog post"

:::Why a section model?
In a section model the content can sit between other elements of a page - like a `<header>` and `<footer>`, for example. 
:::

In your new model use the **New Custom Field** button to create 2 new fields:

1. Text field
    - **Name:** "title"
    - **Required:** Yes
    - **Default value** "I forgot to give this a title"

    (leave the other parameters as their defaults)

2. Text field
    - **Name:** "slug"
    - **Required:** Yes
    - **Default value** "some-slugs-take-their-time"

    (leave the other parameters as their defaults)

Then click the **Save** button in the upper right. 

And put the name of the model in the `.env` file for convenience:
```ini title="/.env" ins={2}
BUILDER_API_PUBLIC_KEY=YOUR_API_KEY
BUILDER_BLOGPOST_MODEL='blogpost'
```

:::caution
This guide relies on these fields being exactly like this and later code will not run correctly if these fields don't exist, are empty, or the titles misspelled.
:::

:::caution[slugs]
There are some pitfalls with the `slug` field:

* Make sure your slug is not just a number. This seems to break the fetch request to Builder's API. 

* Make sure your slugs are unique, since your site's routing will depend on that.
:::

### Setting up the preview URL

:::tip[Official resource]
Read more about [setting up a preview URL with the HTML API](https://www.builder.io/c/docs/html-api#previewing-content-on-your-site).
:::

#### Creating a route for the preview

To use Builder's visual editor, create the page `src/pages/builder-preview.astro` that will render the special `<builder-component>`:

<FileTree title="Project Structure">
- src/
  - pages/
    - **builder-preview.astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content:

```astro title="src/pages/builder-preview.astro"
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
---

<html lang="en">
  <head>
    <title>Preview for builder.io</title>
  </head>
  <body>
    <header>This is your header</header>

    <builder-component model={builderModel} api-key={builderAPIpublicKey}
    ></builder-component>
    <script async src="https://cdn.builder.io/js/webcomponents"></script>

    <footer>This is your footer</footer>
  </body>
</html>

```

`<builder-component>` tells Builder where to insert the content from its CMS - it represents the portion of the page that's editable in the Builder app. In this guide it stands for the content of a blog post. The whole `builder-preview.astro` page recreates how a blog post will be embedded into the site later on - sitting between a `<header>` and a `<footer>`.

The `<script>` tag here won't impact your site's performance, since nobody will visit it, except for developers.   

#### Setting the new route as the preview URL

1. Copy the full URL of your preview to your clipboard. It should include the protocol and go something like this: `https://{your host}/builder-preview`. One way to do this is to run your Astro project (e.g. start the dev server),  type in the route into the address bar of the browser, then click into the address bar again to show the protocol.

2. Go to the **Models** tab in your Builder space, pick the model  you've created and paste the URL from step 1 into the **Preview URL** field. Make sure the URL is complete and includes the protocol, for example `https://`.

3. Click the **Save** button in the upper right. 

:::tip
When you deploy your site, change the preview URL to match your production URL, for example `https://myAwesomeAstroBlog.com/builder-preview`.
:::

#### Testing the preview URL set up 

1. Make sure your site is live (e.g. your dev server is running) and the `/builder-preview` route is working.

2. In your Builder space under the **Content** tab, click on **New** to create a new content entry for your `blogpost` model.

3. In the Builder editor that just opened, you should be able to see the `builder-preview.astro` page with a big inviting **Add Block** in the middle!

:::tip[Troubleshooting]

Things can sometimes go wrong when setting up the preview. If something's not right, you can try one of these things:

* Make sure the site is live - for example, your dev server is running.
* Make sure that the URLs match exactly - the one in your Astro project and the one set in the Builder app.
* Make sure it's the full URL including the protocol, for example `https://`.
* If you're working in a virtual environment like [StackBlitz](https://stackblitz.com/) or [Gitpod](https://www.gitpod.io/), you might have to copy and paste the URL again when you restart your workspace, since this usually generates a new URL for your project.

For more ideas, read [Builder's troubleshooting guide](https://www.builder.io/c/docs/guides/preview-url-working).
:::

### Creating a blog post

:::tip[For visual types]
[See Builder's official blogpost and video about it here](https://www.builder.io/blog/creating-blog#create-a-blog-article).
:::

1. Before you can create new content in Builder, make sure [the preview URL for your model is working](#setting-up-the-preview-url). 

2. Open the visual editor for a content entry of our `blogpost` model. If you've followed [the previous section](#testing-the-preview-url-set-up), you can use that entry. Otherwise create a new one: Go to the **Content** tab in your Builder space and click on **New**. 

3. In the panel on the right under the **options** tab, you should see the data fields `title` and `slug`. These are the fields you've created when you [set up your model](#creating-a-model-for-a-blog-post). Fill them in with the following values:
    - **title:** 'First post, woohoo!'
    - **slug:** 'first-post-woohoo'

4. Design your post. Click on the **Add Block** button and add something - maybe a text field with some text to start with.

5. In the text field above the editor, give your entry a name. This is how it will be listed in the Builder app. 

6. When you're ready click **Publish** button in the upper right corner. 

Your content is now live in the Builder CMS but not part of your Astro project yet. You'll be fetching and displaying it in the following steps. 

Feel free to add as many blog posts as you want, then switch to your favorite code editor to start hacking with Astro!

### Displaying a list of blog posts

Create the page `src/pages/index.astro` that will display a list of post titles, each linking to its own page:

<FileTree title="Project Structure">
- src/
  - pages/
    - **index.astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content:

```astro title="src/pages/index.astro" /title|slug/
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
  `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    fields: ["data.slug", "data.title"].join(","),
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch
  // ...catch some errors...
  ();
---
```

Fetching via the content API returns an array of objects containing data for each post. The `fields` query parameter tells Builder which data is included (see highlighted code). `slug` and `title` should match the names of the custom data fields you've added to [your Builder model](#creating-a-model-for-a-blog-post). 

:::caution[API URls]
URLs used to access APIs change fairly frequently. Check [Builder's API reference](https://www.builder.io/c/docs/content-api-versions) for the latest. 
:::

Use the `posts` array returned from the fetch to display a list of blog posts on the page:

```astro title="src/pages/index.astro" ins={18-99}
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
  `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    fields: ["data.slug", "data.title"].join(","),
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch
  // ...catch some errors...
  ();
---

<html lang="en">
  <head>
    <title>Blog Index</title>
  </head>
  <body>
    <ul>
      {
        posts.map(({ data: { slug, title } }) => (
          <li>
            <a href={`/posts/${slug}`}>{title}</a>
          </li>
        ))
      }
    </ul>
  </body>
</html>

```

Go to your `/` route and you should be able to see a list of links each with the title of a blog post!

:::tip
To debug or fine-tune API results, you can use [Builder's API explorer](https://builder.io/api-explorer).
:::

### Displaying a single blog post

Create the page `src/pages/posts/[slug].astro` that will [dynamically generate a page](/en/core-concepts/routing/#dynamic-routes) for each post.

<FileTree title="Project Structure">
- src/
  - pages/
    - index.astro
    - posts/
      - **[slug].astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the `getStaticPaths` function: 

```astro title="src/pages/posts/[slug].astro"
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

  const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
      {
        apiKey: builderAPIpublicKey,
        fields: ["data.slug", "data.title"].join(","),
        cachebust: "true",
      }
    ).toString()}`
  )
    .then((res) => res.json())
    .catch
    // ...catch some errors...);
    ();

  return [
    ...posts.map(({ data: { slug, title } }) => [
      {
        params: { slug },
        props: { title },
      },
    ]),
  ];
}
---
```

This fetch call is the same you've used to [display a list of blog posts](#displaying-a-list-of-blog-posts). Here, the `getStaticPaths` function creates a static route for each blog post, based on the `slug` data field.

[⚡️ TO REVIEWER: I've looked into ways how to not repeat this fetch call and landed on the `integrations API`. That seemed a little complex. I'm thinking it's not too bad to repeat this code here, but would happily hear suggestions on how to DRY it']

Next, add the following content:

```astro title="src/pages/posts/[slug].astro" ins={30-49}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

  const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
      {
        apiKey: builderAPIpublicKey,
        fields: ["data.slug", "data.title"].join(","),
        cachebust: "true",
      }
    ).toString()}`
  )
    .then((res) => res.json())
    .catch
    // ...catch some errors...);
    ();

  return [
    ...posts.map(({ data: { slug, title } }) => [
      {
        params: { slug },
        props: { title },
      },
    ]),
  ];
}

const { slug } = Astro.params;
const { title } = Astro.props;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
  `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    url: encodedUrl,
    "query.data.slug": slug,
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch
  // ...catch more errors...);
  ();
---
```

The `slug` returned from `getStaticPaths` is used to fetch the corresponding post. The HTML that Builder sends back is made of the blocks you put on the page in Builder's editor.

:::caution
This code relies on the fact that each content entry in the `blogpost` model has non-empty fields called `slug` and `title`. If you didn't create a fresh model for this guide, make sure that all content entries have these fields filled, including those that you started with.
:::

:::note
The variables `builderModel` and `builderAPIpublicKey` need to be created twice, since [`getStaticPaths` runs in its own isolated scope](/en/reference/api-reference/#getstaticpaths).
:::


Finally, render the HTML:

```astro title="src/pages/posts/[slug].astro" ins={52-99}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

  const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
      {
        apiKey: builderAPIpublicKey,
        fields: ["data.slug", "data.title"].join(","),
        cachebust: "true",
      }
    ).toString()}`
  )
    .then((res) => res.json())
    .catch
    // ...catch some errors...);
    ();

  return [
    ...posts.map(({ data: { slug, title } }) => [
      {
        params: { slug },
        props: { title },
      },
    ]),
  ];
}

const { slug } = Astro.params;
const { title } = Astro.props;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
  `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
    apiKey: builderAPIpublicKey,
    url: encodedUrl,
    "query.data.slug": slug,
    cachebust: "true",
  }).toString()}`
)
  .then((res) => res.json())
  .catch
  // ...catch more errors...);
  ();
---

<html lang="en">
  <head>
    <title>{title}</title>
  </head>
  <body>
    <header>This is your header</header>

    <article>
      <Fragment set:html={postHTML} />
    </article>

    <footer>The is your footer</footer>
  </body>
</html>

```

This page matches [the `/builder-preview` page you created previously](#creating-a-route-for-the-preview).

Now when you click on a link on your index route, you should be able to see the blog post!

### Publishing your site

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

#### Rebuild on Builder changes

If your project is using Astro's default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build whenever you click **Publish** in the Builder editor.

##### Netlify

To set up a webhook in Netlify:

1. Go to your site dashboard, then **Site Settings** and click on **Build & deploy**.

2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

To set up a webhook in Vercel:

1. Go to your project dashboard and click on **Settings**.

2. Under the **Git** tab, find the **Deploy Hooks** section.

3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Builder

:::tip[Official resource]
Check out a guide for [setting up a webhook on Builder's blog](https://www.builder.io/c/docs/webhooks).
:::

To set up a webhook in Builder: 

0. Have the URL ready that your hosting provider generated [in the previous step](#rebuild-on-builder-changes).
1. In your Builder dashboard go to the **Models** tab, and pick the **`blogpost`** model. 
2. In the new dialog, click on **Show More Options** and then on **Edit Webhooks** at the bottom.
3. Now add a new webhook by clicking on **Webhook** and then expand the webhook that appeared by clicking on it.
4. Paste the URL from step 0 that was generated by your hosting provider into the **Url** field.
5. The last thing to do is to click on **Show Advanced** under the URL field and click the toggle so that the option **Disable Payload** is **enabled**. Click on **Done** and you're done.

With this set up in place, when you click on the **Publish** button Builder lets your hosting provider know that new content was added. This causes your site to be rebuilt and during this process Astro fetches the newly published data. Nothing to do but lean back and pump out that sweet sweet content. 

:::note
Not disabling the payload can cause the automated build process to break as your site grows and Builder sends more and more data to your hosting provider. With the payload disabled, Builder sends a simpler POST request.
::::


## Official Resources

- Check out [the official Builder.io starter project](https://github.com/BuilderIO/builder/tree/main/examples/astro-solidjs), which uses Astro and SolidJS.
- [Official Builder quickstart guide](https://www.builder.io/c/docs/quickstart#step-1-add-builder-as-a-dependency) - it covers both the use of the REST API as well as through an integration with a JavaScript framework like Qwik, React or Vue. 
- [Builder's API explorer](https://builder.io/api-explorer)

## Community Resources

- Read [Connecting Builder.io's Visual CMS to Astro](https://www.hamatoyogi.dev/blog/astro-log/connecting-builderio-to-astro) by Yoav Ganbar.

